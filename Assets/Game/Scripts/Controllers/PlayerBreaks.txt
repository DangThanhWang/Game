# Hướng dẫn tách nhỏ Player Controller

## 1. Kiến trúc mới với Component Pattern

### Cấu trúc thư mục mới:
```
Assets/Game/Scripts/Controllers/Player/
├── PlayerController.cs (Main controller)
├── Components/
│   ├── PlayerMovement.cs
│   ├── PlayerInput.cs
│   ├── PlayerBounds.cs
│   ├── PlayerShield.cs
│   ├── PlayerVisuals.cs
│   └── PlayerHealth.cs
└── Interfaces/
    └── IPlayerComponent.cs
```

## 2. Interface cơ bản cho các component

```csharp
// IPlayerComponent.cs
public interface IPlayerComponent
{
    void Initialize(PlayerController controller);
    void OnUpdate();
    void OnFixedUpdate();
    void OnDestroy();
}
```

## 3. PlayerController mới (Simplified)

```csharp
public class PlayerController : MonoBehaviour
{
    [Header("Components")]
    private PlayerMovement movement;
    private PlayerInput inputHandler;
    private PlayerBounds bounds;
    private PlayerShield shield;
    private PlayerVisuals visuals;
    private PlayerHealth health;
    
    private List<IPlayerComponent> components = new List<IPlayerComponent>();
    
    // Public properties để components có thể truy cập
    public Rigidbody2D Rigidbody { get; private set; }
    public Camera MainCamera { get; private set; }
    public bool IsPaused { get; private set; }
    
    private void Awake()
    {
        InitializeComponents();
    }
    
    private void InitializeComponents()
    {
        Rigidbody = GetComponent<Rigidbody2D>();
        MainCamera = Camera.main;
        
        // Tạo và khởi tạo các component
        movement = gameObject.AddComponent<PlayerMovement>();
        inputHandler = gameObject.AddComponent<PlayerInput>();
        bounds = gameObject.AddComponent<PlayerBounds>();
        shield = gameObject.AddComponent<PlayerShield>();
        visuals = gameObject.AddComponent<PlayerVisuals>();
        health = gameObject.AddComponent<PlayerHealth>();
        
        // Thêm vào danh sách để quản lý
        components.Add(movement);
        components.Add(inputHandler);
        components.Add(bounds);
        components.Add(shield);
        components.Add(visuals);
        components.Add(health);
        
        // Khởi tạo tất cả components
        foreach (var component in components)
        {
            component.Initialize(this);
        }
    }
    
    private void Update()
    {
        if (IsPaused) return;
        
        foreach (var component in components)
        {
            component.OnUpdate();
        }
    }
    
    private void FixedUpdate()
    {
        if (IsPaused) return;
        
        foreach (var component in components)
        {
            component.OnFixedUpdate();
        }
    }
    
    public void SetPaused(bool paused)
    {
        IsPaused = paused;
    }
}
```

## 4. Component cụ thể

### PlayerMovement.cs
```csharp
public class PlayerMovement : MonoBehaviour, IPlayerComponent
{
    [SerializeField] private float moveSpeed = 5f;
    [SerializeField] private float smoothing = 0.1f;
    [SerializeField] private HingeJoint2D[] wheels;
    
    private PlayerController controller;
    private Vector2 targetPosition;
    private Vector2 currentVelocity;
    private bool isMoving;
    private JointMotor2D motor;
    
    public Vector2 TargetPosition
    {
        get => targetPosition;
        set
        {
            targetPosition = value;
            isMoving = true;
        }
    }
    
    public void Initialize(PlayerController controller)
    {
        this.controller = controller;
        targetPosition = transform.position;
        
        if (wheels.Length > 0)
            motor = wheels[0].motor;
    }
    
    public void OnUpdate() { }
    
    public void OnFixedUpdate()
    {
        HandleMovement();
    }
    
    private void HandleMovement()
    {
        if (!isMoving)
        {
            controller.Rigidbody.velocity = Vector2.zero;
            return;
        }
        
        // Áp dụng boundary constraints
        var bounds = GetComponent<PlayerBounds>();
        if (bounds != null)
        {
            targetPosition = bounds.ClampPosition(targetPosition);
        }
        
        targetPosition.y = transform.position.y;
        
        Vector2 newPosition = Vector2.SmoothDamp(
            controller.Rigidbody.position,
            targetPosition,
            ref currentVelocity,
            smoothing
        );
        
        controller.Rigidbody.MovePosition(newPosition);
        
        if (Vector2.Distance(controller.Rigidbody.position, targetPosition) < 0.1f)
        {
            isMoving = false;
        }
    }
    
    public void OnDestroy() { }
}
```

### PlayerInput.cs
```csharp
public class PlayerInput : MonoBehaviour, IPlayerComponent
{
    private PlayerController controller;
    private PlayerMovement movement;
    
    public void Initialize(PlayerController controller)
    {
        this.controller = controller;
        movement = GetComponent<PlayerMovement>();
        
        SubscribeToEvents();
    }
    
    public void OnUpdate()
    {
        HandleLegacyInput();
    }
    
    public void OnFixedUpdate() { }
    
    private void HandleLegacyInput()
    {
        if (Input.GetMouseButton(0))
        {
            Vector3 mouseWorldPos = controller.MainCamera.ScreenToWorldPoint(Input.mousePosition);
            movement.TargetPosition = new Vector2(mouseWorldPos.x, mouseWorldPos.y);
        }
    }
    
    private void SubscribeToEvents()
    {
        EventManager.Subscribe<PlayerInputEvent>(OnPlayerInput);
    }
    
    private void OnPlayerInput(PlayerInputEvent inputEvent)
    {
        switch (inputEvent.Type)
        {
            case InputType.TouchStart:
            case InputType.TouchMove:
                movement.TargetPosition = inputEvent.Position;
                break;
        }
    }
    
    public void OnDestroy()
    {
        EventManager.Unsubscribe<PlayerInputEvent>(OnPlayerInput);
    }
}
```

### PlayerBounds.cs
```csharp
public class PlayerBounds : MonoBehaviour, IPlayerComponent
{
    [SerializeField] private float boundaryOffset = 0.56f;
    
    private PlayerController controller;
    private float screenBounds;
    
    public void Initialize(PlayerController controller)
    {
        this.controller = controller;
        CalculateScreenBounds();
    }
    
    public void OnUpdate() { }
    public void OnFixedUpdate() { }
    
    private void CalculateScreenBounds()
    {
        if (controller.MainCamera != null)
        {
            screenBounds = controller.MainCamera.ScreenToWorldPoint(new Vector3(Screen.width, 0f, 0f)).x - boundaryOffset;
        }
        else
        {
            screenBounds = GameManager.Instance.ScreenWidth - boundaryOffset;
        }
    }
    
    public Vector2 ClampPosition(Vector2 position)
    {
        position.x = Mathf.Clamp(position.x, -screenBounds, screenBounds);
        return position;
    }
    
    public void OnDestroy() { }
}
```

### PlayerShield.cs
```csharp
public class PlayerShield : MonoBehaviour, IPlayerComponent
{
    [SerializeField] private GameObject shieldPrefab;
    
    private PlayerController controller;
    public GameObject Shield { get; private set; }
    
    public void Initialize(PlayerController controller)
    {
        this.controller = controller;
        CreateShield();
    }
    
    public void OnUpdate() { }
    public void OnFixedUpdate() { }
    
    private void CreateShield()
    {
        Shield = Instantiate(shieldPrefab);
        Shield.transform.SetParent(transform);
        Shield.transform.localPosition = Vector3.zero;
        Shield.tag = "Shield";
        Shield.SetActive(false);
    }
    
    public void ActivateShield(float duration)
    {
        StartCoroutine(ShieldCoroutine(duration));
    }
    
    private IEnumerator ShieldCoroutine(float duration)
    {
        if (Shield == null) yield break;
        
        Shield.SetActive(true);
        yield return new WaitForSeconds(duration);
        Shield.SetActive(false);
    }
    
    public void OnDestroy() { }
}
```

### PlayerVisuals.cs
```csharp
public class PlayerVisuals : MonoBehaviour, IPlayerComponent
{
    private PlayerController controller;
    private SpriteRenderer spriteRenderer;
    private Color originalColor;
    
    public bool IsInvisible { get; private set; }
    
    public void Initialize(PlayerController controller)
    {
        this.controller = controller;
        spriteRenderer = GetComponent<SpriteRenderer>();
        originalColor = spriteRenderer.color;
    }
    
    public void OnUpdate() { }
    public void OnFixedUpdate() { }
    
    public void SetInvisible(float duration)
    {
        StartCoroutine(InvisibleCoroutine(duration));
    }
    
    private IEnumerator InvisibleCoroutine(float duration)
    {
        IsInvisible = true;
        spriteRenderer.color = new Color(originalColor.r, originalColor.g, originalColor.b, 0.5f);
        
        yield return new WaitForSeconds(duration);
        
        spriteRenderer.color = originalColor;
        IsInvisible = false;
    }
    
    public void OnDestroy() { }
}
```

## 5. Lợi ích của kiến trúc mới

### Separation of Concerns
- Mỗi component chỉ lo một nhiệm vụ cụ thể
- Dễ debug và maintain
- Code dễ đọc và hiểu

### Modularity
- Có thể bật/tắt features dễ dàng
- Tái sử dụng components cho các GameObject khác
- Dễ mở rộng thêm tính năng mới

### Testing
- Test từng component độc lập
- Mock dependencies dễ dàng
- Unit test hiệu quả hơn

### Performance
- Chỉ update những component cần thiết
- Có thể optimize từng component riêng biệt

## 6. Cách migration từ code cũ

1. **Backup code cũ**
2. **Tạo interface IPlayerComponent**
3. **Tách từng feature thành component riêng**
4. **Update PlayerController để sử dụng components**
5. **Test từng component**
6. **Refactor PowerUps để sử dụng components mới**

## 7. PowerUps với kiến trúc mới

```csharp
// ShieldPowerUp.cs (Updated)
public class ShieldPowerUp : IPowerUpDefend
{
    public PowerUpType Type => PowerUpType.Shield;

    public void Apply(PlayerController controller, float duration)
    {
        var shield = controller.GetComponent<PlayerShield>();
        shield?.ActivateShield(duration);
    }
}

// InvisiblePowerUp.cs (Updated)
public class InvisiblePowerUp : IPowerUpDefend
{
    public PowerUpType Type => PowerUpType.Invisible;

    public void Apply(PlayerController controller, float duration)
    {
        var visuals = controller.GetComponent<PlayerVisuals>();
        visuals?.SetInvisible(duration);
    }
}
```

Kiến trúc này giúp code dễ maintain, test và mở rộng hơn nhiều so với monolithic PlayerController hiện tại.
